# 广告请求竞价流程

## 1. 前端发起广告填充请求

### 1.1 SDK 初始化
```java
// 在 Application 中初始化 SDK
public class MyApplication extends Application {
    @Override
    public void onCreate() {
        super.onCreate();
        AdServerClient.getInstance().init(this, "your_app_id", "your_app_key");
    }
}
```

### 1.2 发起广告请求
```java
// 在需要展示广告的地方
public class MainActivity extends AppCompatActivity {
    private BannerAdView bannerAdView;
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        
        // 创建广告视图
        bannerAdView = new BannerAdView(this);
        bannerAdView.setAdSize(AdSize.BANNER);
        bannerAdView.setAdUnitId("your_ad_unit_id");
        
        // 设置广告监听器
        bannerAdView.setAdListener(new AdListener() {
            @Override
            public void onAdLoaded() {
                // 广告加载成功
            }
            
            @Override
            public void onAdFailedToLoad(LoadAdError error) {
                // 广告加载失败
            }
        });
        
        // 加载广告
        bannerAdView.loadAd();
    }
}
```

## 2. 后端向 AN 发起询价

### 2.1 后端接收请求
```javascript
// 后端 API 路由
app.post('/api/ad/request', async (req, res) => {
    const { 
        appId,
        adUnitId,
        deviceInfo,
        userInfo 
    } = req.body;
    
    // 记录请求日志
    logger.info('收到广告请求', { appId, adUnitId });
    
    // 向 AN 发起询价
    const bids = await requestBidsFromANs({
        appId,
        adUnitId,
        deviceInfo,
        userInfo
    });
    
    res.json(bids);
});
```

### 2.2 询价请求处理
```javascript
async function requestBidsFromANs(params) {
    const bids = [];
    
    // 并行向多个 AN 发起询价
    const bidPromises = [
        requestBidFromTopOn(params),
        requestBidFromMintegral(params),
        requestBidFromInMobi(params)
    ];
    
    try {
        const results = await Promise.all(bidPromises);
        bids.push(...results.filter(bid => bid !== null));
    } catch (error) {
        logger.error('AN 询价失败', error);
    }
    
    return bids;
}
```

## 3. AN 反馈询价结果

### 3.1 AN 响应处理
```javascript
async function requestBidFromTopOn(params) {
    try {
        const response = await axios.post('https://api.topon.com/bid', {
            appId: params.appId,
            adUnitId: params.adUnitId,
            deviceInfo: params.deviceInfo,
            userInfo: params.userInfo
        });
        
        if (response.data && response.data.price > 0) {
            return {
                source: 'topon',
                price: response.data.price,
                adUnitId: params.adUnitId,
                creative: response.data.creative
            };
        }
    } catch (error) {
        logger.error('TopOn 询价失败', error);
    }
    return null;
}
```

## 4. 后端进行竞价判断

### 4.1 竞价逻辑
```javascript
function determineWinningBid(bids) {
    if (!bids || bids.length === 0) {
        return null;
    }
    
    // 按价格排序
    bids.sort((a, b) => b.price - a.price);
    
    // 选择最高价
    const winningBid = bids[0];
    
    // 记录竞价结果
    logger.info('竞价结果', {
        winningSource: winningBid.source,
        winningPrice: winningBid.price,
        totalBids: bids.length
    });
    
    return winningBid;
}
```

## 5. 后端向胜出 AN 反馈

### 5.1 通知胜出 AN
```javascript
async function notifyWinningAN(winningBid) {
    try {
        const response = await axios.post(`https://api.${winningBid.source}.com/win`, {
            bidId: winningBid.bidId,
            price: winningBid.price
        });
        
        logger.info('已通知胜出 AN', {
            source: winningBid.source,
            status: response.status
        });
    } catch (error) {
        logger.error('通知胜出 AN 失败', error);
    }
}
```

## 6. 后端通知 SDK 胜出 AN

### 6.1 返回竞价结果
```javascript
app.post('/api/ad/request', async (req, res) => {
    // ... 前面的代码 ...
    
    // 确定胜出 AN
    const winningBid = determineWinningBid(bids);
    
    if (winningBid) {
        // 通知胜出 AN
        await notifyWinningAN(winningBid);
        
        // 返回结果给 SDK
        res.json({
            status: 'success',
            winningSource: winningBid.source,
            price: winningBid.price,
            creative: winningBid.creative
        });
    } else {
        res.json({
            status: 'no_bid'
        });
    }
});
```

## 7. SDK 调用 AN SDK 加载广告

### 7.1 加载广告实现
```java
public class BannerAdView extends AdView {
    @Override
    protected void loadAdWithAdapter(String source, JSONObject response) {
        switch (source) {
            case "topon":
                loadTopOnAd(response);
                break;
            case "mintegral":
                loadMintegralAd(response);
                break;
            case "inmobi":
                loadInMobiAd(response);
                break;
            default:
                Log.e(TAG, "未知的广告来源: " + source);
        }
    }
    
    private void loadTopOnAd(JSONObject response) {
        try {
            String placementId = response.getString("placementId");
            TopOnAdLoader.getInstance().loadBannerAd(
                getContext(),
                placementId,
                new TopOnAdListener() {
                    @Override
                    public void onAdLoaded(View adView) {
                        showAd(adView);
                    }
                    
                    @Override
                    public void onAdFailed(String error) {
                        Log.e(TAG, "TopOn 广告加载失败: " + error);
                    }
                }
            );
        } catch (JSONException e) {
            Log.e(TAG, "解析 TopOn 响应失败", e);
        }
    }
}
```

## 8. SDK 展示广告素材

### 8.1 广告展示实现
```java
public class BannerAdView extends AdView {
    private void showAd(View adView) {
        // 移除旧广告
        removeAllViews();
        
        // 添加新广告
        addView(adView);
        
        // 记录展示
        AdServerClient.getInstance().trackImpression(getAdUnitId());
        
        // 通知监听器
        if (adListener != null) {
            adListener.onAdLoaded();
        }
    }
    
    @Override
    public void setOnClickListener(OnClickListener listener) {
        super.setOnClickListener(v -> {
            // 记录点击
            AdServerClient.getInstance().trackClick(getAdUnitId());
            
            // 调用原始监听器
            if (listener != null) {
                listener.onClick(v);
            }
        });
    }
}
```

## 9. 完整流程示例

### 9.1 前端调用示例
```java
// 创建广告视图
BannerAdView bannerAdView = new BannerAdView(context);
bannerAdView.setAdSize(AdSize.BANNER);
bannerAdView.setAdUnitId("your_ad_unit_id");

// 设置监听器
bannerAdView.setAdListener(new AdListener() {
    @Override
    public void onAdLoaded() {
        // 广告加载成功
    }
    
    @Override
    public void onAdFailedToLoad(LoadAdError error) {
        // 广告加载失败
    }
    
    @Override
    public void onAdClicked() {
        // 广告被点击
    }
});

// 加载广告
bannerAdView.loadAd();
```

### 9.2 后端处理示例
```javascript
// 接收广告请求
app.post('/api/ad/request', async (req, res) => {
    const { appId, adUnitId, deviceInfo, userInfo } = req.body;
    
    // 1. 向 AN 发起询价
    const bids = await requestBidsFromANs({
        appId,
        adUnitId,
        deviceInfo,
        userInfo
    });
    
    // 2. 确定胜出 AN
    const winningBid = determineWinningBid(bids);
    
    if (winningBid) {
        // 3. 通知胜出 AN
        await notifyWinningAN(winningBid);
        
        // 4. 返回结果给 SDK
        res.json({
            status: 'success',
            winningSource: winningBid.source,
            price: winningBid.price,
            creative: winningBid.creative
        });
    } else {
        res.json({
            status: 'no_bid'
        });
    }
});
```

## 8. 代码实现分析

### 8.1 前端实现（Android SDK）

#### 8.1.1 广告请求发起
```java
// AdView.java
public void loadAd() {
    Logger.d(TAG, "开始加载广告: " + adUnitId);
    
    // 创建广告请求
    AdRequest request = createAdRequest();
    
    // 直接调用后端API获取竞价结果
    AdServerClient.getInstance(context).requestBid(request, new AdServerCallback() {
        @Override
        public void onBidResponse(BidResponse response) {
            Logger.d(TAG, "收到竞价响应: " + response.getPlatform());
            bidResponse = response;
            
            // 使用对应平台的适配器加载广告
            loadAdWithAdapter(response.getPlatform(), response);
        }
        
        @Override
        public void onError(String error) {
            Logger.e(TAG, "广告请求失败: " + error);
            onAdFailedToLoad(error);
        }
    });
}
```

#### 8.1.2 设备信息和用户信息收集
```java
// AdRequest.java
private void initRequestData() {
    try {
        // 添加设备信息
        requestData.put("deviceId", getDeviceId());
        requestData.put("deviceModel", android.os.Build.MODEL);
        requestData.put("deviceBrand", android.os.Build.BRAND);
        requestData.put("osVersion", android.os.Build.VERSION.RELEASE);
        
        // 添加用户信息
        requestData.put("language", java.util.Locale.getDefault().getLanguage());
        requestData.put("country", java.util.Locale.getDefault().getCountry());
        requestData.put("timezone", java.util.TimeZone.getDefault().getID());
    } catch (JSONException e) {
        Logger.e(TAG, "初始化请求数据失败", e);
    }
}
```

### 8.2 后端实现（SpringBoot）

#### 8.2.1 竞价服务
```java
// BidService.java
@Service
public class BidService {
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Autowired
    private KafkaTemplate<String, String> kafkaTemplate;
    
    @Autowired
    private List<AdPlatformService> adPlatformServices;
    
    public CompletableFuture<BidResponse> processBid(BidRequest request) {
        // 检查缓存
        String cacheKey = "bid:" + request.getPlacementId();
        BidResponse cachedResponse = (BidResponse) redisTemplate.opsForValue().get(cacheKey);
        if (cachedResponse != null) {
            return CompletableFuture.completedFuture(cachedResponse);
        }
        
        // 发送到Kafka
        return CompletableFuture.supplyAsync(() -> {
            kafkaTemplate.send("bid-requests", request.toString());
            
            // 并行执行所有平台的竞价
            List<BidResponse> responses = adPlatformServices.parallelStream()
                .map(service -> service.bid(request))
                .collect(Collectors.toList());
            
            // 选择最高出价
            return responses.stream()
                .max((r1, r2) -> Double.compare(r1.getPrice(), r2.getPrice()))
                .orElse(new BidResponse());
        });
    }
}
```

#### 8.2.2 广告平台服务
```java
// UnityAdsService.java
@Service
public class UnityAdsService implements AdPlatformService {
    @Override
    @Retryable(value = {AdPlatformException.class}, maxAttempts = 3, backoff = @Backoff(delay = 1000, multiplier = 2))
    @Cacheable(value = "bidResponses", key = "#root.target.CACHE_KEY_PREFIX + #placementId")
    public Map<String, Object> bid(String placementId, Map<String, Object> params) {
        log.info("开始Unity Ads竞价请求，placementId: {}", placementId);
        
        try {
            // 构建Unity Ads特定的请求
            UnityAdsBidRequest request = buildUnityAdsRequest(placementId, params);
            
            // 发送请求并处理响应
            ResponseEntity<UnityAdsBidResponse> response = restTemplate.exchange(
                config.getUnityAds().getApiUrl(),
                HttpMethod.POST,
                new HttpEntity<>(request, headers),
                UnityAdsBidResponse.class
            );
            
            // 处理响应并返回结果
            return processResponse(response);
        } catch (Exception e) {
            throw new AdPlatformException("Unity Ads竞价异常", e);
        }
    }
}
```

## 9. 实现总结

### 9.1 流程对应关系

1. 步骤1：客户端发起广告请求 ✅
   - 实现：`AdView.java` 中的 `loadAd()` 方法
   - 功能：创建广告请求，收集设备信息和用户信息

2. 步骤2：服务器检查缓存 ✅
   - 实现：`BidService.java` 中的 `processBid()` 方法
   - 功能：使用 Redis 检查缓存，避免重复竞价

3. 步骤3：发送竞价请求到 Kafka ✅
   - 实现：`BidService.java` 中的 Kafka 消息发送
   - 功能：异步处理竞价请求

4. 步骤4：并行询价 ✅
   - 实现：`BidService.java` 中的并行流处理
   - 功能：同时向多个广告平台发起询价

5. 步骤5：竞价响应 ✅
   - 实现：各个广告平台服务类
   - 功能：处理各平台的竞价响应

6. 步骤6：选择最高出价 ✅
   - 实现：`BidService.java` 中的 `max()` 操作
   - 功能：根据价格选择胜出平台

7. 步骤7：通知胜出平台 ✅
   - 实现：各个广告平台服务类
   - 功能：向胜出平台发送通知

8. 步骤8：缓存竞价结果 ✅
   - 实现：`BidService.java` 中的 `handleBidResponse()` 方法
   - 功能：缓存竞价结果，设置5分钟过期

9. 步骤9：返回胜出平台信息 ✅
   - 实现：`AdServerClient.java` 中的 `requestBid()` 方法
   - 功能：将结果返回给客户端

10. 步骤10：调用对应平台 SDK 加载广告 ✅
    - 实现：各个广告平台适配器
    - 功能：使用对应平台的 SDK 加载广告

11. 步骤11：展示广告 ✅
    - 实现：各个广告平台适配器中的 `showAd()` 方法
    - 功能：展示加载的广告

12. 步骤12-15：事件追踪 ✅
    - 实现：`MetricsService.java` 和 `AdStatsServiceImpl.java`
    - 功能：记录广告展示、点击等事件

### 9.2 额外功能

1. 广告统计 ✅
   - 实现：`AdStatsServiceImpl.java`
   - 功能：记录和分析广告数据

2. 指标监控 ✅
   - 实现：`MetricsService.java`
   - 功能：监控系统性能和广告效果

3. 配置管理 ✅
   - 实现：`AdConfigServiceImpl.java`
   - 功能：管理广告配置

4. 缓存管理 ✅
   - 实现：`CacheConfig.java`
   - 功能：管理不同级别的缓存

### 9.3 总结

前后端代码基本按照 `ad_bidding_flow.mmd` 的流程实现了广告竞价系统，并且还增加了一些额外的功能来支持系统的运行和监控。代码实现完整，包含了所有必要的步骤和功能。系统采用了现代化的技术栈，包括：

- 前端：Android SDK，支持多平台适配
- 后端：SpringBoot，提供高性能的REST API
- 缓存：Redis，提供快速的数据访问
- 消息队列：Kafka，处理异步任务
- 监控：Micrometer，提供系统指标监控

系统设计合理，代码结构清晰，易于维护和扩展。

